'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash.get');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.reduce');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isfunction');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isobject');

var _lodash8 = _interopRequireDefault(_lodash7);

var _lodash9 = require('lodash.set');

var _lodash10 = _interopRequireDefault(_lodash9);

var _lodash11 = require('lodash.unset');

var _lodash12 = _interopRequireDefault(_lodash11);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = function (engine) {
    var whitelist = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var blacklist = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

    whitelist = whitelist || []; // eslint-disable-line no-param-reassign

    return _extends({}, engine, {
        save: function save(state) {
            var saveState = {};

            // Copy the whole state if we're about to blacklist only
            if (whitelist.length === 0 && blacklist.length > 0) {
                saveState = _extends({}, state);
            }

            whitelist.forEach(function (key) {
                // Support strings for one-level paths
                if (typeof key === 'string') {
                    key = [key]; // eslint-disable-line no-param-reassign
                }

                var value = (0, _lodash4['default'])(key, function (result, keyPart) {
                    if (result) {
                        // Support immutable structures
                        if ((0, _lodash6['default'])(result.has) && (0, _lodash6['default'])(result.get)) {
                            return result.get(keyPart);
                        }

                        if (result.hasOwnProperty(keyPart)) {
                            return result[keyPart];
                        }
                    }
                }, state);

                if (value !== undefined) {
                    // done to support null values
                    (0, _lodash10['default'])(saveState, key, value);
                }
            });

            blacklist.forEach(function (key) {
                // Support strings for one-level paths
                if (typeof key === 'string') {
                    key = [key]; // eslint-disable-line no-param-reassign
                }

                // Support immutable structures
                var value = state[key[0]];
                var blacklistedState = saveState[key[0]] || value;

                if (blacklistedState && (0, _lodash6['default'])(blacklistedState.deleteIn)) {
                    // Handle multiple blacklist path with same key
                    saveState[key[0]] = blacklistedState.deleteIn(key.slice(1));
                    return;
                }

                // If we're a nested path ...
                if (key.length > 1) {
                    // ... and inside a object ...
                    var myKey = key.slice(0, -1);
                    var subValue = (0, _lodash2['default'])(saveState, myKey);
                    if ((0, _lodash8['default'])(subValue)) {
                        // ... clone it, as we don't want to change the state!
                        (0, _lodash10['default'])(saveState, myKey, _extends({}, subValue));
                    }
                }
                (0, _lodash12['default'])(saveState, key);
            });

            return engine.save(saveState);
        }
    });
};